<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Conference Admin Panel</title>
		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}

			body {
				font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
					sans-serif;
				background-color: #f0f2f5;
				color: #1a1a1a;
			}

			.container {
				max-width: 1400px;
				margin: 0 auto;
				padding: 20px;
			}

			.header {
				background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
				color: white;
				padding: 30px;
				border-radius: 16px;
				margin-bottom: 30px;
				box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
			}

			.header h1 {
				font-size: 2.5rem;
				margin-bottom: 10px;
			}

			.header p {
				display: flex;
				align-items: center;
				gap: 10px;
			}

			.status-indicator {
				display: inline-block;
				width: 12px;
				height: 12px;
				border-radius: 50%;
				animation: pulse 2s infinite;
			}

			.status-indicator.connected {
				background: #48bb78;
			}

			.status-indicator.disconnected {
				background: #e53e3e;
				animation: none;
			}

			@keyframes pulse {
				0% {
					opacity: 1;
				}
				50% {
					opacity: 0.5;
				}
				100% {
					opacity: 1;
				}
			}

			.stats-grid {
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
				gap: 20px;
				margin-bottom: 30px;
			}

			.stat-card {
				background: white;
				padding: 25px;
				border-radius: 12px;
				box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
				transition: transform 0.2s, box-shadow 0.2s;
			}

			.stat-card:hover {
				transform: translateY(-2px);
				box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
			}

			.stat-card h3 {
				color: #666;
				font-size: 0.9rem;
				margin-bottom: 10px;
				text-transform: uppercase;
			}

			.stat-value {
				font-size: 2.5rem;
				font-weight: bold;
				color: #667eea;
			}

			.main-grid {
				display: grid;
				grid-template-columns: 1fr 1fr;
				gap: 30px;
				margin-bottom: 30px;
			}

			@media (max-width: 968px) {
				.main-grid {
					grid-template-columns: 1fr;
				}
			}

			.section {
				background: white;
				border-radius: 12px;
				padding: 25px;
				box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
			}

			.section h2 {
				margin-bottom: 20px;
				color: #333;
				display: flex;
				align-items: center;
				gap: 10px;
			}

			.btn {
				background: #667eea;
				color: white;
				border: none;
				padding: 12px 24px;
				border-radius: 8px;
				font-size: 14px;
				font-weight: 500;
				cursor: pointer;
				transition: all 0.2s;
				margin: 5px;
			}

			.btn:hover {
				background: #5a67d8;
				transform: translateY(-1px);
			}

			.btn:disabled {
				background: #cbd5e0;
				cursor: not-allowed;
				transform: none;
			}

			.btn-danger {
				background: #e53e3e;
			}

			.btn-danger:hover {
				background: #c53030;
			}

			.btn-success {
				background: #48bb78;
			}

			.btn-success:hover {
				background: #38a169;
			}

			.btn-warning {
				background: #ed8936;
			}

			.btn-warning:hover {
				background: #dd6b20;
			}

			.queue-item,
			.speaker-card,
			.user-item {
				background: #f8f9fa;
				padding: 20px;
				border-radius: 8px;
				margin-bottom: 15px;
				display: flex;
				justify-content: space-between;
				align-items: center;
				transition: all 0.2s;
			}

			.queue-item:hover,
			.user-item:hover {
				background: #e9ecef;
			}

			.speaker-card {
				background: #e6fffa;
				border: 2px solid #4fd1c5;
				animation: pulse-green 2s infinite;
			}

			@keyframes pulse-green {
				0%,
				100% {
					border-color: #4fd1c5;
				}
				50% {
					border-color: #38b2ac;
				}
			}

			.user-info h4 {
				font-size: 1.1rem;
				margin-bottom: 5px;
			}

			.user-info span {
				color: #666;
				font-size: 0.9rem;
			}

			.btn-group {
				display: flex;
				gap: 10px;
			}

			.empty-state {
				text-align: center;
				padding: 40px;
				color: #999;
			}

			.empty-state svg {
				width: 64px;
				height: 64px;
				margin-bottom: 20px;
				opacity: 0.3;
			}

			.timer {
				display: inline-block;
				background: #667eea;
				color: white;
				padding: 4px 12px;
				border-radius: 20px;
				font-size: 0.9rem;
				font-weight: 500;
			}

			.live-audio-section {
				background: white;
				border-radius: 12px;
				padding: 25px;
				box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
				margin-bottom: 30px;
			}

			.audio-controls {
				display: flex;
				gap: 15px;
				margin-bottom: 20px;
				flex-wrap: wrap;
			}

			.volume-control {
				display: flex;
				align-items: center;
				gap: 10px;
				margin-bottom: 20px;
			}

			.volume-slider {
				flex: 1;
				max-width: 200px;
			}

			.live-indicator {
				display: none;
				align-items: center;
				gap: 10px;
				margin-bottom: 20px;
			}

			.live-dot {
				width: 12px;
				height: 12px;
				background: #ff4757;
				border-radius: 50%;
				animation: pulse 1.5s infinite;
			}

			.audio-queue {
				max-height: 300px;
				overflow-y: auto;
			}

			.queue-audio-item {
				background: rgba(102, 126, 234, 0.05);
				padding: 15px;
				border-radius: 8px;
				margin-bottom: 10px;
				display: flex;
				justify-content: space-between;
				align-items: center;
				border-left: 4px solid #667eea;
			}

			.queue-audio-item.playing {
				border-left-color: #48bb78;
				background: rgba(72, 187, 120, 0.1);
			}

			.queue-audio-item.played {
				opacity: 0.6;
				border-left-color: #666;
			}

			.chunk-info {
				display: flex;
				gap: 20px;
				font-size: 14px;
			}

			.user-item.speaking {
				background: #e6fffa;
				border: 1px solid #4fd1c5;
			}

			.user-item.queued {
				background: #fef3c7;
				border: 1px solid #f59e0b;
			}

			.status-badge {
				display: inline-block;
				padding: 4px 8px;
				border-radius: 4px;
				font-size: 12px;
				font-weight: 500;
				margin-left: 10px;
			}

			.status-badge.speaking {
				background: #4fd1c5;
				color: #234e52;
			}

			.status-badge.queued {
				background: #f59e0b;
				color: #78350f;
			}

			.status-badge.connected {
				background: #48bb78;
				color: #22543d;
			}

			.logs {
				background: #f8f9fa;
				border: 1px solid #e2e8f0;
				padding: 15px;
				border-radius: 8px;
				max-height: 200px;
				overflow-y: auto;
				font-family: "Courier New", monospace;
				font-size: 12px;
				margin-top: 20px;
			}

			.log-entry {
				margin-bottom: 5px;
				padding: 2px 0;
			}

			.log-info {
				color: #4299e1;
			}
			.log-success {
				color: #48bb78;
			}
			.log-warning {
				color: #ed8936;
			}
			.log-error {
				color: #e53e3e;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<!-- Header -->
			<div class="header">
				<h1>üéµ Conference Speaker Management</h1>
				<p>
					<span class="status-indicator connected" id="connectionStatus"></span>
					<span id="connectionText">Connected</span>
				</p>
			</div>

			<!-- Stats Grid -->
			<div class="stats-grid">
				<div class="stat-card">
					<h3>Total Users</h3>
					<div class="stat-value" id="totalUsers">0</div>
				</div>
				<div class="stat-card">
					<h3>Queue Length</h3>
					<div class="stat-value" id="queueLength">0</div>
				</div>
				<div class="stat-card">
					<h3>Active Admins</h3>
					<div class="stat-value" id="totalAdmins">0</div>
				</div>
				<div class="stat-card">
					<h3>Speaking Time</h3>
					<div class="stat-value" id="speakingTime">0:00</div>
				</div>
			</div>

			<!-- Live Audio Section -->
			<div class="live-audio-section">
				<h2>üîä Live Audio Stream</h2>

				<div class="live-indicator" id="liveIndicator">
					<div class="live-dot"></div>
					<span>LIVE STREAMING</span>
				</div>

				<div class="audio-controls">
					<button
						class="btn btn-success"
						onclick="enableAudio()"
						id="enableBtn"
					>
						üéß Enable Audio
					</button>
					<button class="btn" onclick="testAudio()">üîä Test Sound</button>
					<button class="btn btn-warning" onclick="clearAudioQueue()">
						üóëÔ∏è Clear Audio Queue
					</button>
					<button class="btn btn-danger" onclick="toggleMute()" id="muteBtn">
						üîá Mute
					</button>
				</div>

				<div class="volume-control">
					<span>üîä Volume:</span>
					<input
						type="range"
						class="volume-slider"
						id="volumeSlider"
						min="0"
						max="100"
						value="50"
						onchange="updateVolume(this.value)"
					/>
					<span id="volumeValue">50%</span>
				</div>

				<div class="audio-queue" id="audioQueueContainer">
					<h3>Audio Chunks Queue</h3>
					<div id="audioQueue">
						<div class="empty-state">
							<p>No audio chunks in queue</p>
						</div>
					</div>
				</div>
			</div>

			<!-- Main Grid -->
			<div class="main-grid">
				<!-- Current Speaker Section -->
				<div class="section">
					<h2>üé§ Current Speaker</h2>
					<div id="currentSpeaker">
						<div class="empty-state">
							<svg
								viewBox="0 0 24 24"
								fill="none"
								stroke="currentColor"
								stroke-width="2"
							>
								<circle cx="12" cy="12" r="10"></circle>
								<line x1="12" y1="8" x2="12" y2="12"></line>
								<line x1="12" y1="16" x2="12.01" y2="16"></line>
							</svg>
							<p>No active speaker</p>
						</div>
					</div>
				</div>

				<!-- Queue Section -->
				<div class="section">
					<h2>üë• Speaker Queue</h2>
					<div id="speakerQueue">
						<div class="empty-state">
							<svg
								viewBox="0 0 24 24"
								fill="none"
								stroke="currentColor"
								stroke-width="2"
							>
								<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
								<line x1="9" y1="9" x2="15" y2="15"></line>
								<line x1="15" y1="9" x2="9" y2="15"></line>
							</svg>
							<p>No speakers in queue</p>
						</div>
					</div>
				</div>
			</div>

			<!-- Connected Users Section -->
			<div class="section">
				<h2>üë• Connected Users</h2>
				<div id="connectedUsers">
					<div class="empty-state">
						<svg
							viewBox="0 0 24 24"
							fill="none"
							stroke="currentColor"
							stroke-width="2"
						>
							<path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
							<circle cx="12" cy="7" r="4"></circle>
						</svg>
						<p>No users connected</p>
					</div>
				</div>
			</div>

			<!-- Activity Logs -->
			<div class="section">
				<h2>üìã Activity Logs</h2>
				<div class="logs" id="logs">
					<div class="log-entry log-info">üîÑ Initializing admin panel...</div>
				</div>
			</div>
		</div>

		<script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
		<script>
			// Global state management
			let socket = null;
			let audioContext = null;
			let audioQueue = [];
			let currentlyPlaying = null;
			let isAudioEnabled = false;
			let isMuted = false;
			let volume = 0.5;
			let speakingTimer = null;
			let speakingStartTime = null;

			// DOM Elements cache
			const dom = {
				connectionStatus: document.getElementById("connectionStatus"),
				connectionText: document.getElementById("connectionText"),
				totalUsers: document.getElementById("totalUsers"),
				queueLength: document.getElementById("queueLength"),
				totalAdmins: document.getElementById("totalAdmins"),
				speakingTime: document.getElementById("speakingTime"),
				currentSpeaker: document.getElementById("currentSpeaker"),
				speakerQueue: document.getElementById("speakerQueue"),
				connectedUsers: document.getElementById("connectedUsers"),
				liveIndicator: document.getElementById("liveIndicator"),
				audioQueue: document.getElementById("audioQueue"),
				enableBtn: document.getElementById("enableBtn"),
				muteBtn: document.getElementById("muteBtn"),
				volumeValue: document.getElementById("volumeValue"),
				logs: document.getElementById("logs"),
			};

			// Initialize
			function init() {
				log("üöÄ Starting conference admin panel...", "info");
				connectToServer();
			}

			// Socket Management
			function connectToServer() {
				log("üîó Connecting to server...", "info");

				socket = io(window.location.origin, {
					transports: ["websocket", "polling"],
				});

				socket.on("connect", () => {
					updateConnectionStatus(true);
					log("‚úÖ Connected to server", "success");

					// Identify as admin
					socket.emit("admin:connect");
				});

				socket.on("disconnect", () => {
					updateConnectionStatus(false);
					log("‚ùå Disconnected from server", "error");
				});

				// Conference events
				socket.on("state:update", (state) => {
					log("üìä State update received", "info");
					updateStats(state.stats);
					updateQueue(state.queue);
					updateCurrentSpeaker(state.activeSpeaker);
					updateConnectedUsers(state.connectedUsers);
				});

				socket.on("speaker:started", (speaker) => {
					log(`üé§ ${speaker.name} started speaking`, "success");
					startSpeakingTimer(speaker.startTime);
				});

				socket.on("speaker:ended", (speaker) => {
					log(`üõë ${speaker.name} stopped speaking`, "warning");
					stopSpeakingTimer();
				});

				socket.on("user:connected", (user) => {
					log(`üë§ ${user.name} connected`, "info");
				});

				// Audio streaming events
				socket.on("streaming:start", (data) => {
					log(
						`üéµ Live audio streaming started from ${data.userName}`,
						"success"
					);
					dom.liveIndicator.style.display = "flex";
				});

				socket.on("streaming:end", (data) => {
					log(`üõë Live audio streaming ended`, "warning");
					dom.liveIndicator.style.display = "none";
				});

				socket.on("audio:chunk", async (data) => {
					if (isAudioEnabled && !isMuted) {
						await handleAudioChunk(data);
					}
				});
			}

			// Audio Management
			async function handleAudioChunk(chunkData) {
				try {
					// Convert base64 to blob
					const binaryString = atob(chunkData.audio);
					const bytes = new Uint8Array(binaryString.length);
					for (let i = 0; i < binaryString.length; i++) {
						bytes[i] = binaryString.charCodeAt(i);
					}

					const blob = new Blob([bytes], {
						type: chunkData.mimeType || "audio/mp4",
					});
					const url = URL.createObjectURL(blob);

					// Create audio element
					const audio = new Audio();
					audio.src = url;
					audio.volume = volume;
					audio.preload = "auto";

					const queueItem = {
						id: chunkData.chunkNumber,
						audio: audio,
						url: url,
						data: chunkData,
						status: "queued",
					};

					audioQueue.push(queueItem);
					updateAudioQueueDisplay();

					// Auto-play if nothing is currently playing
					if (!currentlyPlaying) {
						playNextChunk();
					}

					log(`üéµ Audio chunk ${chunkData.chunkNumber} received`, "info");
				} catch (error) {
					log(`‚ùå Error processing audio chunk: ${error.message}`, "error");
				}
			}

			async function playNextChunk() {
				if (audioQueue.length === 0 || currentlyPlaying) return;

				const chunk = audioQueue.find((c) => c.status === "queued");
				if (!chunk) return;

				try {
					currentlyPlaying = chunk;
					chunk.status = "playing";
					updateAudioQueueDisplay();

					chunk.audio.addEventListener("ended", () => {
						chunk.status = "played";
						currentlyPlaying = null;
						URL.revokeObjectURL(chunk.url);
						updateAudioQueueDisplay();
						playNextChunk();
					});

					chunk.audio.addEventListener("error", (e) => {
						chunk.status = "error";
						currentlyPlaying = null;
						URL.revokeObjectURL(chunk.url);
						updateAudioQueueDisplay();
						playNextChunk();
					});

					await chunk.audio.play();
				} catch (error) {
					log(`‚ùå Failed to play chunk: ${error.message}`, "error");
					chunk.status = "error";
					currentlyPlaying = null;
					playNextChunk();
				}
			}

			function enableAudio() {
				if (!audioContext) {
					audioContext = new (window.AudioContext ||
						window.webkitAudioContext)();
				}

				if (audioContext.state === "suspended") {
					audioContext.resume().then(() => {
						isAudioEnabled = true;
						dom.enableBtn.textContent = "‚úÖ Audio Enabled";
						dom.enableBtn.disabled = true;
						log("üéß Audio enabled - you will now hear live audio", "success");
					});
				} else {
					isAudioEnabled = true;
					dom.enableBtn.textContent = "‚úÖ Audio Enabled";
					dom.enableBtn.disabled = true;
					log("üéß Audio enabled - you will now hear live audio", "success");
				}
			}

			function testAudio() {
				if (!audioContext) {
					log("‚ùå Please enable audio first", "error");
					return;
				}

				try {
					const oscillator = audioContext.createOscillator();
					const gainNode = audioContext.createGain();

					oscillator.connect(gainNode);
					gainNode.connect(audioContext.destination);

					oscillator.frequency.value = 440;
					gainNode.gain.value = volume * 0.1;

					oscillator.start();
					oscillator.stop(audioContext.currentTime + 0.5);

					log("üîä Playing test tone", "info");
				} catch (error) {
					log(`‚ùå Test audio failed: ${error.message}`, "error");
				}
			}

			function toggleMute() {
				isMuted = !isMuted;
				dom.muteBtn.textContent = isMuted ? "üîä Unmute" : "üîá Mute";

				audioQueue.forEach((chunk) => {
					if (chunk.audio) {
						chunk.audio.volume = isMuted ? 0 : volume;
					}
				});

				log(isMuted ? "üîá Audio muted" : "üîä Audio unmuted", "info");
			}

			function updateVolume(value) {
				volume = value / 100;
				dom.volumeValue.textContent = value + "%";

				audioQueue.forEach((chunk) => {
					if (chunk.audio && !isMuted) {
						chunk.audio.volume = volume;
					}
				});

				log(`üîä Volume set to ${value}%`, "info");
			}

			function clearAudioQueue() {
				audioQueue.forEach((chunk) => {
					if (chunk.audio) {
						chunk.audio.pause();
					}
					if (chunk.url) {
						URL.revokeObjectURL(chunk.url);
					}
				});

				audioQueue = [];
				currentlyPlaying = null;
				updateAudioQueueDisplay();
				log("üóëÔ∏è Audio queue cleared", "warning");
			}

			// Conference Management Functions
			function acceptUser(userId) {
				if (socket) {
					socket.emit("admin:accept:user", { userId });
					log(`‚úÖ Accepted user request`, "success");
				}
			}

			function rejectUser(userId) {
				if (socket) {
					socket.emit("admin:reject:user", { userId });
					log(`‚ùå Rejected user request`, "warning");
				}
			}

			function endSpeaker() {
				if (socket) {
					socket.emit("admin:end:speaker");
					log(`üõë Ended current speaker`, "warning");
				}
			}

			// UI Update Functions
			function updateConnectionStatus(connected) {
				dom.connectionStatus.className = `status-indicator ${
					connected ? "connected" : "disconnected"
				}`;
				dom.connectionText.textContent = connected
					? "Connected"
					: "Disconnected";
			}

			function updateStats(stats) {
				dom.totalUsers.textContent = stats.totalUsers || 0;
				dom.queueLength.textContent = stats.queueLength || 0;
				dom.totalAdmins.textContent = stats.totalAdmins || 0;
			}

			function updateQueue(queue) {
				if (!queue || queue.length === 0) {
					dom.speakerQueue.innerHTML = `
                    <div class="empty-state">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                            <line x1="9" y1="9" x2="15" y2="15"></line>
                            <line x1="15" y1="9" x2="9" y2="15"></line>
                        </svg>
                        <p>No speakers in queue</p>
                    </div>
                `;
					return;
				}

				dom.speakerQueue.innerHTML = queue
					.map(
						(user, index) => `
                <div class="queue-item">
                    <div class="user-info">
                        <h4>${user.name}</h4>
                        <span>Position: ${
													index + 1
												} ‚Ä¢ Waiting: ${formatWaitTime(user.requestedAt)}</span>
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-success" onclick="acceptUser('${
													user.id
												}')">‚úÖ Accept</button>
                        <button class="btn btn-danger" onclick="rejectUser('${
													user.id
												}')">‚ùå Reject</button>
                    </div>
                </div>
            `
					)
					.join("");
			}

			function updateCurrentSpeaker(speaker) {
				if (!speaker) {
					dom.currentSpeaker.innerHTML = `
                    <div class="empty-state">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="8" x2="12" y2="12"></line>
                            <line x1="12" y1="16" x2="12.01" y2="16"></line>
                        </svg>
                        <p>No active speaker</p>
                    </div>
                `;
					stopSpeakingTimer();
					return;
				}

				dom.currentSpeaker.innerHTML = `
                <div class="speaker-card">
                    <div class="user-info">
                        <h4>üé§ ${speaker.name}</h4>
                        <span>Speaking for: <span class="timer">${formatSpeakingTime(
													speaker.startTime
												)}</span></span>
                    </div>
                    <button class="btn btn-danger" onclick="endSpeaker()">üõë End Speaking</button>
                </div>
            `;

				if (speaker.startTime) {
					startSpeakingTimer(speaker.startTime);
				}
			}

			function updateConnectedUsers(users) {
				if (!users || users.length === 0) {
					dom.connectedUsers.innerHTML = `
                    <div class="empty-state">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                            <circle cx="12" cy="7" r="4"></circle>
                        </svg>
                        <p>No users connected</p>
                    </div>
                `;
					return;
				}

				dom.connectedUsers.innerHTML = users
					.map((user) => {
						let statusBadge = "";
						let itemClass = "user-item";

						if (user.isSpeaking) {
							statusBadge =
								'<span class="status-badge speaking">üé§ Speaking</span>';
							itemClass += " speaking";
						} else if (user.isInQueue) {
							statusBadge =
								'<span class="status-badge queued">‚è≥ In Queue</span>';
							itemClass += " queued";
						} else {
							statusBadge =
								'<span class="status-badge connected">‚úÖ Connected</span>';
						}

						return `
                    <div class="${itemClass}">
                        <div class="user-info">
                            <h4>${user.name}${statusBadge}</h4>
                            <span>Joined: ${formatWaitTime(
															user.joinedAt
														)}</span>
                        </div>
                    </div>
                `;
					})
					.join("");
			}

			function updateAudioQueueDisplay() {
				if (audioQueue.length === 0) {
					dom.audioQueue.innerHTML = `
                    <div class="empty-state">
                        <p>No audio chunks in queue</p>
                    </div>
                `;
					return;
				}

				const html = audioQueue
					.slice(-5)
					.map((chunk) => {
						// Show last 5 chunks
						const statusIcon =
							{
								queued: "‚è≥",
								playing: "‚ñ∂Ô∏è",
								played: "‚úÖ",
								error: "‚ùå",
							}[chunk.status] || "‚ùì";

						const size = (chunk.data.size / 1024).toFixed(1);

						return `
                    <div class="queue-audio-item ${chunk.status}">
                        <div class="chunk-info">
                            <span>${statusIcon} Chunk ${chunk.id}</span>
                            <span>üìè ${size}KB</span>
                            <span>üéµ ${chunk.data.format}</span>
                            <span>‚è±Ô∏è ${new Date(
															chunk.data.timestamp
														).toLocaleTimeString()}</span>
                        </div>
                    </div>
                `;
					})
					.join("");

				dom.audioQueue.innerHTML = html;
			}

			// Timer Functions
			function startSpeakingTimer(startTime) {
				speakingStartTime = startTime || Date.now();

				if (speakingTimer) clearInterval(speakingTimer);

				speakingTimer = setInterval(() => {
					const elapsed = Date.now() - speakingStartTime;
					dom.speakingTime.textContent = formatDuration(elapsed);

					const timerElement = dom.currentSpeaker.querySelector(".timer");
					if (timerElement) {
						timerElement.textContent = formatDuration(elapsed);
					}
				}, 1000);
			}

			function stopSpeakingTimer() {
				if (speakingTimer) {
					clearInterval(speakingTimer);
					speakingTimer = null;
				}
				dom.speakingTime.textContent = "0:00";
				speakingStartTime = null;
			}

			// Utility Functions
			function formatWaitTime(timestamp) {
				const seconds = Math.floor((Date.now() - timestamp) / 1000);
				return formatDuration(seconds * 1000);
			}

			function formatSpeakingTime(startTime) {
				const elapsed = Date.now() - startTime;
				return formatDuration(elapsed);
			}

			function formatDuration(ms) {
				const seconds = Math.floor(ms / 1000);
				const minutes = Math.floor(seconds / 60);
				const remainingSeconds = seconds % 60;
				return `${minutes}:${remainingSeconds.toString().padStart(2, "0")}`;
			}

			function log(message, type = "info") {
				const timestamp = new Date().toLocaleTimeString();
				const logEntry = document.createElement("div");
				logEntry.className = `log-entry log-${type}`;
				logEntry.textContent = `[${timestamp}] ${message}`;

				dom.logs.appendChild(logEntry);
				dom.logs.scrollTop = dom.logs.scrollHeight;

				// Keep only last 50 log entries
				while (dom.logs.children.length > 50) {
					dom.logs.removeChild(dom.logs.firstChild);
				}
			}

			// Initialize when page loads
			document.addEventListener("DOMContentLoaded", init);
		</script>
	</body>
</html>
